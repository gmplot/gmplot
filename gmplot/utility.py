import sys
import os
import shutil
import inspect
import warnings

_INDENT_LEVEL = 4
_INDENT = ' ' * _INDENT_LEVEL
# Note: This should match a single indent used in the actual source code.

if sys.version_info.major == 2:
    from StringIO import StringIO as _StringIO

    class StringIO(_StringIO):
        def __enter__(self):
            return self

        def __exit__(self, exception_type, exception_value, traceback):
            '''
            :param exception_type: Type of exception that triggered the exit. 
            :param exception_value: Value of exception that triggered the exit.
            :param traceback: Traceback when exit was triggered.
            '''
            self.close()

else:
    from io import StringIO # pragma: no coverage

def _get_fresh_path(relative_path):
    '''
    Delete the contents of a given relative path then get its absolute path.

    :param relative_path: Relative path to be cleaned up and returned as an absolute path.
    :return: Absolute path of the given relative path.
    '''
    path = os.path.abspath(relative_path)
    if os.path.exists(path):
        shutil.rmtree(path)
    os.mkdir(path)
    return path

def _write_to_sidebar(file, name, link=None, depth=0):
    '''
    Add an item to the GitHub Wiki _Sidebar file as a link.

    :param file: _Sidebar file handle.
    :param name: Readable name of the item to be added.
    :param link: (optional) Link to the item of interest.
        If not specified, the item name will be used as the link.
    :param depth: (optional) Indentation level of the given item in the _Sidebar.
        Defaults to 0.
    '''
    link_content = name
    if link is not None and name != link:
        link_content += '|' + link

    file.write(_INDENT * depth + '* **[[%s]]**' % link_content)
    file.write('\n')

class _GenerateDocFiles(object):
    '''
    Functor that autogenerates Sphinx source files for each public object (with a docstring)
    under a given module. This also adds corresponding GitHub Wiki _Sidebar links for each
    generated file. 
    '''

    def __init__(self, module, doc_directory, sidebar_file):
        '''
        :param module: Module to parse and autogenerate documentation for.
        :param doc_directory: Sphinx directory to create the source files in.
        :param sidebar_file: GitHub Wiki _Sidebar file handle.
        '''
        self.module = module
        self.doc_directory = doc_directory
        self.source_ext = '.rst'
        self.sidebar_file = sidebar_file

    def __call__(self):
        '''
        :return: The extension of the autogenerated Sphinx source files.
        '''
        self._recurse(self.module, [])
        return self.source_ext

    def _recurse(self, element, ancestry):
        '''
        Helper function that recurses through the module tree to autogenerate documentation.

        :param element: Element to process.
        :param ancestry: Current ancestry of the element, as a list ordered from its highest
            ancestor to its immediate parent.
        '''
        for name, item in element.__dict__.items():
            # Skip private and non-public items:
            if name[0] == '_':
                continue

            # Get the bound form of the element's item, if applicable
            # (this ensures that the actual item's docstring is read below):
            if hasattr(item, '__get__'):
                item = item.__get__(element)

            # Skip items that don't have a docstring:
            if item.__doc__ is None:
                continue

            # Get this item's ancestry:
            new_ancestry = ancestry.copy()
            new_ancestry.append(name)
            full_name = '.'.join(new_ancestry)

            # Determine the proper Sphinx directive for the item:
            doc_type = None
            if inspect.isroutine(item): # TODO: Likely incomplete - this doesn't handle modules nor attributes, for example.
                doc_type = 'automethod'
            elif inspect.isclass(item):
                doc_type = 'autoclass'
            else:
                warnings.warn("`%s`'s type isn't supported in documentation (or it isn't implemented yet)." % full_name)
                continue

            # Generate the Sphinx source file for this item:
            with open('%s/%s%s' % (self.doc_directory, full_name, self.source_ext), 'w') as file:
                file.write(':orphan:\n\n')
                file.write('.. %s:: %s::%s\n' % (doc_type, self.module.__name__, full_name))

            # Add a link to this item in the _Sidebar file:
            _write_to_sidebar(self.sidebar_file, name, full_name, len(ancestry))

            # Continue parsing the module tree:
            self._recurse(item, new_ancestry)

def _bookend(string, fragment):
    '''
    Bookend a given string with the given fragment on both ends.

    :param string: String to bookend.
    :param fragment: Fragment to bookend the string with.
    :return: Bookended string.
    '''
    if not string:
        return ''

    if string.startswith(fragment) and string.endswith(fragment):
        return string

    return fragment + string + fragment

def _pretty_format_signature_header(signature_header):
    '''
    Pretty format a given Markdown signature header.

    :param signature_header: Signature header to format.
    :return: Formatted signature header.

    Given:
        ### class module.function(param1, param2=None)
    
    Output:
        _class_ module.**function**(_param1, param2=None_)
    '''
    new_header = ''

    # Trim the closing parenthesis:
    if signature_header[-1] != ')':
        return None
    signature_header = signature_header[:-1]

    # Split the parameters from the rest of the signature header:
    parenthesis_index = signature_header.find('(')
    if parenthesis_index == -1:
        return None

    parameters = _bookend(signature_header[parenthesis_index + 1:], '_')
    signature_header = signature_header[:parenthesis_index]
 
    # Split the rest of the signature header by whitespace:
    header_sections = signature_header.split()

    # Ensure the first portion of the header is a valid header level (e.g. '#' or '####'):
    header_level = header_sections[0]
    HEADER_CHARACTER = '#'
    if header_level[0] != HEADER_CHARACTER or header_level != len(header_level) * header_level[0]:
        return None

    # Get the annotation and full name portions of the header:
    if len(header_sections) == 2:
        annotation = None
        full_name = header_sections[1]
    elif len(header_sections) == 3:
        annotation = header_sections[1]
        full_name = header_sections[2]
    else:
        return None

    # If an annotation exists (e.g. 'class' or 'method'), add it to the new header,
    # and italicize it if needed:
    if annotation:
        new_header += _bookend(annotation, '_') + ' '

    # Split the scope from the name:
    last_period_index = full_name.rfind('.')
    if last_period_index == -1:
        return None

    scope = full_name[:last_period_index]
    name = _bookend(full_name[last_period_index + 1:], '**')

    # Rebuild the signature using the new format:
    new_header += scope + '.' + name + '(' + parameters + ')'

    return new_header

def _pretty_format_markdown(directory):
    '''
    Pretty format all Markdown files in the given directory.

    :param directory: Directory containing the Markdown files to format. 
    '''
    for filename in os.listdir(directory):

        # Skip non-Markdown files:
        if not filename.endswith(".md"):
            continue

        # Read the file's contents:
        with open(directory + filename, 'r') as file:
            lines = file.readlines()

        # Skip if there's no content:
        if not lines:
            continue

        # Pretty format the signature header:
        lines[0] = _pretty_format_signature_header(lines[0][:-1]) # (exclude trailing newline)
        if lines[0] is None:
            warnings.warn("Couldn't parse `%s`'s signature header." % filename)
            continue
        lines[0] += '\n'

        # Add a line break right after the header:
        lines.insert(1, '\n')
        lines.insert(2, '---\n')
        lines.insert(3, '\n')

        # Ensure all literal blocks get Python highlighting:
        in_literal_block = False
        CODE_LITERAL_SYMBOL = '```'
        for index, line in enumerate(lines):
            if line.startswith(CODE_LITERAL_SYMBOL):
                if not in_literal_block:
                    in_literal_block = True
                    lines[index] = CODE_LITERAL_SYMBOL + 'python\n'
                else:
                    in_literal_block = False
        if in_literal_block:
            warnings.warn('Unclosed literal block in `%s`.'  % filename)
            continue

        # Update the file:
        with open(directory + filename, 'w') as file:
            file.writelines(lines)
